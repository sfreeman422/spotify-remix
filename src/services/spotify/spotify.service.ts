import axios from 'axios';
import { UserService } from '../user/user.service';
import { SpotifyUserData } from './spotify.interface';

export class SpotifyService {
  baseUrl = 'https://api.spotify.com/v1';
  baseSelfUrl = `${this.baseUrl}/me`;
  baseUserUrl = `${this.baseUrl}/users`;
  basePlaylistUrl = `${this.baseUrl}/playlists`;

  userService = new UserService();

  getUserData(accessToken: string): Promise<SpotifyUserData> {
    return axios
      .get(this.baseSelfUrl, {
        headers: {
          Authorization: 'Bearer ' + accessToken,
        },
      })
      .then(response => {
        return response.data;
      })
      .catch(e => {
        console.error(e);
        throw new Error(e);
      });
  }

  getUserPlaylists(accessToken: string): Promise<any> {
    return axios.get(this.basePlaylistUrl, {
      headers: {
        Authorization: accessToken,
      },
    });
  }

  createUserPlaylist(accessToken: string): Promise<any> {
    return this.userService.getUser({ accessToken: accessToken.split(' ')[1] }).then(user => {
      if (user) {
        return axios
          .post(
            `${this.baseUserUrl}/${user.spotifyId}/playlists`,
            {
              name: `${user.spotifyId}'s Remix Playlist`,
              public: false,
              collaborative: true,
              description: 'Playlist generated by SpotifyRemix',
            },
            {
              headers: {
                Authorization: accessToken,
              },
            },
          )
          .then(playlist => {
            return this.userService
              .savePlaylist(user, playlist.data.id)
              .then(playlist => this.populatePlaylist(playlist.playlistId));
          });
      } else {
        throw new Error('Unable to find user');
      }
    });
  }

  removeUserPlaylist(_accessToken: string) {
    console.log('not yet implemented');
  }

  subscribeToPlaylist(_accessToken: string, _playlistId: string) {
    console.log('not yet implemented');
  }

  async populatePlaylist(playlistId: string) {
    // get list of owners + subscribers (as far as WE know, we cannot use tthe followers key) in the playlist
    const members = await this.userService.getPlaylist(playlistId).then(playlist => {
      return playlist[0]?.members;
    });
    // For each member, get most recently playec + liked tracks
    const music: any[] = members?.length
      ? await Promise.all(
          members.map(async member => {
            const userMusic = await Promise.all([
              axios
                .get(`${this.baseSelfUrl}/top/tracks?limit=50&time_range=short_term`, {
                  headers: {
                    Authorization: `Bearer ${member.accessToken}`,
                  },
                })
                .then(x =>
                  x.data.items.map((song: any) => ({
                    ...song,
                    accessToken: member.accessToken,
                    refreshToken: member.refreshToken,
                  })),
                )
                .catch(e => console.error(e)),
              axios
                .get(`${this.baseSelfUrl}/tracks?limit=50`, {
                  headers: {
                    Authorization: `Bearer ${member.accessToken}`,
                  },
                })
                .then(x =>
                  x.data.items.map((song: any) => ({
                    ...song,
                    accessToken: member.accessToken,
                    refreshToken: member.refreshToken,
                  })),
                )
                .catch(e => console.error(e)),
            ]);

            return userMusic.flat();
          }),
        )
      : [];

    const numberOfItemsPerUser = this.getNumberOfItemsPerUser(members.length);
    const itemsByUserMap: Record<string, number> = {};
    // Create a list of songs to add to the playlist.
    // Save those songs in the DB to keep track of what has been added to a given playlist.
    const playlistItems: any[] = [];

    music?.flat().forEach(item => {
      const { accessToken } = item;
      // Do this after you add tthe song.
      if (itemsByUserMap[accessToken] && itemsByUserMap[accessToken] < numberOfItemsPerUser) {
        playlistItems.push(item);
        itemsByUserMap[accessToken] += 1;
      } else if (!itemsByUserMap[accessToken]) {
        playlistItems.push(item);
        itemsByUserMap[accessToken] = 1;
      }
    });
    // We will want to round robin sort by access token here i believe.
    // Fire off mad network requests to add to playlist.

    console.log(playlistItems.length);
    // Need to add rate limit error handling here with retry logic.
    return await Promise.all(
      this.roundRobinSort(playlistItems).map(song => {
        return axios
          .post(
            `${this.basePlaylistUrl}/${playlistId}/tracks`,
            {
              uris: [song.uri],
            },
            {
              headers: {
                Authorization: `Bearer ${song.accessToken}`,
              },
            },
          )
          .catch(e => console.error(e));
      }),
    );
  }

  roundRobinSort(arr: any[]): any[] {
    const allSongs = arr;
    let sortedArr: any[] = [];
    while (allSongs.length > 0) {
      const orderedSet: any[] = [];
      for (let i = 0; i < allSongs.length; i += 1) {
        const found = orderedSet.find(element => element.accessToken === allSongs[i].accessToken);
        if (!found) {
          orderedSet.push(allSongs[i]);
          allSongs.splice(i, 1);
          i -= 1;
        }
      }
      sortedArr = sortedArr.concat(orderedSet);
    }
    return sortedArr;
  }

  // This function sucks, but basically if we have under 10 ppl, use 50 songs total, if we have more than 10, use 5 songs each.
  getNumberOfItemsPerUser(numberOfUsers: number) {
    const minSongsPerUser = numberOfUsers * 6;
    const maxNumberOfSongs = 48;
    return minSongsPerUser > maxNumberOfSongs ? minSongsPerUser : Math.round(maxNumberOfSongs / numberOfUsers);
  }
}
